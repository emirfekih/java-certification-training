[
  { "chapterId":1,
  "chapterName": "Java Building Blocks",
  "passed": false,"chevron":false,
  "covered":[
             {"title":"Java Basics","covers":["Define the scope of variables","Define the structure of a Java class",
                 "Create executable Java applications with a main method; run a Java program from the command line; including console output",
                  "Import other Java packages to make them accessible in your code","Compare and contrast the features and components of Java such as platform independence, object orientation, encapsulation, etc."]
             },

         {"title":"Working with Java Data Types","covers":["Declare and initialize variables (including casting or primitive types)",
           "Differentiate between object reference variables and primitive variables",
           "Know how to read or write to object fields",
           "Explain an Object’s Lifecycle (creation,dereference by reassignment and garbage collection)"]}
         ],

  "objectives":["Be able to write code using a main() method.","Understand the effect of using packages and imports","Be able to identify legal and illegal declarations and initialization","Be able to recognize a constructor",
    "Be able to determine where variables go into and out of scope.",
    "Be able to recognize misplaced statements in a class.","Know how to identify when an object is eligible for garbage collection"],
  "summary":["In this chapter, you saw that Java classes consist of members called fields and methods. An object is an instance of a Java class. There are three styles of comment: a single-line comment (//), a multiline comment (/* */), and a Javadoc comment (/** */).",
    "Java begins program execution with a main() method. The most common signature for this method run from the command line is public static void main(String[] args). Arguments are passed in after the class name, as in java NameOfClass firstArgument.Arguments are indexed starting with 0. ",
    "Java code is organized into folders called packages. To reference classes in other packages,you use an import statement. A wildcard ending an import statement means you want to import all classes in that package. It does not include packages that are inside that one. java.lang is a special package that does not need to be imported.",
    "Primitive types are the basic building blocks of Java types. They are assembled into reference types. Reference types can have methods and be assigned to null. In addition to “normal” numbers, numeric literals are allowed to begin with 0 (octal), 0x (hex), 0X (hex), 0b (binary), or 0B (binary). Numeric literals are also allowed to contain underscores as long as they are directly between two other numbers.",
    "Constructors create Java objects. A constructor is a method matching the class name and omitting the return type. When an object is instantiated, fi elds and blocks of code are initialized first. Then the constructor is run.",
    "Declaring a variable involves stating the data type and giving the variable a name.Variables that represent fi elds in a class are automatically initialized to their corresponding    “zero” or null value during object instantiation. Local variables must be specifically initialized. Identifiers may contain letters, numbers, $, or _. Identifi ers may not begin withnumbers.",
    "Scope refers to that portion of code where a variable can be accessed. There are three kinds of variables in Java, depending on their scope: instance variables, class variables, and local variables. Instance variables are the nonstatic fi elds of your class. Class variables are the static fields within a class. Local variables are declared within a method.",
    "For some class elements, order matters within the fi le. The package statement comes first if present. Then comes the import statements if present. Then comes the class declaration. Fields and methods are allowed to be in any order within the class.",
    "Garbage collection is responsible for removing objects from memory when they can never be used again. An object becomes eligible for garbage collection when there are no more references to it or its references have all gone out of scope. The finalize() method will run once for each object if/when it is fi rst garbage collected.",
   "Java code is object oriented, meaning all code is defi ned in classes. Access modifiers allow classes to encapsulate data. Java is platform independent, compiling to bytecode. It is robust and simple by not providing pointers or operator overloading. Finally, Java is secure because it runs inside a virtual machine."
   ]
  },




  { "chapterId":2,
    "chapterName": "Operators & Statements",
    "passed": false,"chevron":false,
    "covered":[{"title":"Using Operators and Decision Constructs","covers":["Use Java operators; including parentheses to override operator precedence","Create if and if/else and ternary constructs","Use a switch statement"]},{"title":"Using Loop Constructs","covers":["Create and use while loops","Create and use for loops including the enhanced for loop","Create and use do/while loops","Compare loop constructs","Use break and continue"]}],
    "objectives":["Be able to write code that uses Java operators","Be able to recognize which operators are associated with which data types.","Understand Java operator precedence","Be able to write code that uses parentheses to override operator precedence","Understand if and switch decision control statements.","Understand loop statements","Understand how break and continue can change flow control"],
    "summary":["This chapter covered a wide variety of topics, including dozens of Java operators, along with numerous control fl ow statements. Many of these operators and statements may have been new to you.","",
      "It is important that you understand how to use all of the required Java operators covered in this chapter and know how operator precedence infl uences the way a particular expression is interpreted. There will likely be numerous questions on the exam that appear to test  one thing, such as StringBuilder or exception handling, when in fact the answer is relatedto the misuse of a particular operator that causes the application to fail to compile. When you see an operator on the exam, always check that the appropriate data types are used and that they match each other where applicable",
      "For statements, this chapter covered two types of control structures: decision-making controls structures, including if-then, if-then-else, and switch statements, as well as repetition control structures including for, for-each, while, and do-while. Remember that most of these structures require the evaluation of a particular boolean expression either for branching decisions or once per repetition. The switch statement is the only one that supports a variety of data types, including String variables as of Java 7.",
      "With a for-each statement you don’t need to explicitly write a boolean expression, since the compiler builds them implicitly. For clarity, we referred to an enhanced for loop as a for-each loop, but syntactically they are written as a for statement.",
      "We concluded this chapter by discussing advanced control options and how fl ow can beenhanced through nested loops, break statements, and continue statements. Be wary of questions on the exam that use nested statements, especially ones with labels, and verify they are being used correctly.",
      "This chapter is especially important because at least one component of this chapter will likely appear in every exam question with sample code. Many of the questions on the exam focus on proper syntactic use of the structures, as they will be a large source of questions that end in “Does not compile.” You should be able to answer all of the review questions correctly or fully understand those that you answered incorrectly before moving on to later chapters."]
  },


  { "chapterId":3,
    "chapterName": "Core Java APIs",
    "passed": false,"chevron":false,
    "covered":[{"title":"Using Operators and Decision Constructs","covers":["Test equality between Strings and other objects using == and equals()"]},
      {"title":"Creating and Using Arrays","covers":["Declare, instantiate, initialize and use a one-dimensional array","Declare, instantiate, initialize and use a multi-dimensional array"]},
      {"title":"Working with Selected classes from the Java API","covers":["Creating and manipulating Strings","Manipulate data using the StringBuilder class and its methods","Declare and use an ArrayList of a given type","Create and manipulate calendar data using classes from java.time.LocalDateTime, java.time.LocalDate, java.time.Local-Time, java.time.format.DateTimeFormatter, java.time.Period"]},
      {"title":"Working with Java Data Types","covers":["Develop code that uses wrapper classes such as Boolean,Double, and Integer."]}],
    "objectives":["Be able to determine the output of code using String","Be able to determine the output of code using StringBuilder","Be able to determine the output of code using StringBuilder","Understand the difference between == and equals.","Be able to determine the output of code using arrays.","Be able to determine the output of code using ArrayList","Recognize invalid uses of dates and times."],
    "summary":["In this chapter, you learned that Strings are immutable sequences of characters. The new operator is optional. The concatenation operator (+) creates a new String with the content of the fi rst String followed by the content of the second String. If either operand involved in the + expression is a String, concatenation is used; otherwise, addition is used. String literals are stored in the string pool. The String class has many methods. You need to know charAt(), concat(), endsWith(), equals(), equalsIgnoreCase(), indexOf(),length(), replace(), startsWith(), substring(), toLowerCase(), toUpperCase(), and trim(). ",
      "StringBuilders are mutable sequences of characters. Most of the methods return a reference to the current object to allow method chaining. The StringBuilder class has many methods. You need to know append(), charAt(), delete(), deleteCharAt(), indexOf(), insert(), length(), reverse(), substring(), and toString(). StringBuffer is the same as StringBuilder except that it is thread safe.",
      "Calling == on String objects will check whether they point to the same object in the pool. Calling == on StringBuilder references will check whether they are pointing to the same StringBuilder object. Calling equals() on String objects will check whether the sequence of characters is the same. Calling equals() on StringBuilder objects will check whether they are pointing to the same object rather than looking at the values inside.",
      "An array is a fi xed-size area of memory on the heap that has space for primitives or pointers to objects. You specify the size when creating it—for example, int[] a = new int[6];. Indexes begin with 0 and elements are referred to using a[0]. The Arrays.sort() method sorts an array. Arrays.binarySearch() searches a sorted array and returns the index of a match. If no match is found, it negates the position where the element would need to be inserted and subtracts 1. Methods that are passed varargs (…) can be used as if a normal array was passed in. In a multidimensional array, the second-level arrays and beyond can be different sizes. ",
      "An ArrayList can change size over its life. It can be stored in an ArrayList or List reference. Generics can specify the type that goes in the ArrayList. You need to know the methods add(), clear(), contains(), equals(), isEmpty(), remove(), set(), and size(). Although an ArrayList is not allowed to contain primitives, Java will autobox parameters passed in to the proper wrapper type. Collections.sort() sorts an ArrayList.",
      "A LocalDate contains just a date, a LocalTime contains just a time, and a LocalDateTime contains both a date and time. All three have private constructors and are created using LocalDate.now() or LocalDate.of() (or the equivalents for that class). Dates and times can be manipulated using plusXXX or minusXXX methods. The Period class represents a number of days, months, or years to add or subtract from a LocalDate or LocalDateTime. DateTimeFormatter is used to output dates and times in the desired format. The date and time classes are all immutable, which means the return value must be used."]
  },


  { "chapterId":4,
    "chapterName": "Methods and Encapsulation",
    "passed": false,"chevron":false,
    "covered":[{"title":"Working with Methods and Encapsulation","covers":["Create methods with arguments and return values; including overloaded methods","Apply the static keyword to methods and fields","Create and overload constructors; include impact on default constructors","Apply access modifiers","Apply encapsulation principles to a class","Determine the effect upon object references and primitive values when they are passed into methods that change the values"]},
      {"title":"Working with Selected classes from the Java API","covers":["Write a simple Lambda expression that consumes a Lambda Predicate expression"]}],
    "objectives":["Be able to identify correct and incorrect method declarations","Identify when a method or field is accessible","Recognize valid and invalid uses of static imports","State the output of code involving methods.","Evaluate code involving constructors.","Be able to recognize when a class is properly encapsulated.","Write simple lambda expressions."],
    "summary":["As you learned in this chapter, Java methods start with an access modifi er of public,private, protected or blank (default access). This is followed by an optional specifi er such as static, final, or abstract. Next comes the return type, which is void or a Java type. The method name follows, using standard Java identifi er rules. Zero or more parameters go in parentheses as the parameter list. Next come any optional exception types. Finally, zero or more statements go in braces to make up the method body.",
      "Using the private keyword means the code is only available from within the same class.Default (package private) access means the code is only available from within the same package. Using the protected keyword means the code is available from the same package or subclasses. Using the public keyword means the code is available from anywhere. Static methods and static variables are shared by the class. When referenced from outside the class, they are called using the classname—for example, StaticClass.method(). Instance members are allowed to call static members, but static members are not allowed to call instance members. Static imports are used to import static members. ",
      "Java uses pass-by-value, which means that calls to methods create a copy of the parameters. Assigning new values to those parameters in the method doesn’t affect the caller’s variables",
      "Calling methods on objects that are method parameters changes the state of those objects and is refl ected in the caller.",
      "Overloaded methods are methods with the same name but a different parameter list.Java calls the most specific method it can find. Exact matches are preferred, followed by wider primitives. After that comes autoboxing and finally varargs.",
      "Constructors are used to instantiate new objects. The default no-argument constructor is called when no constructor is coded. Multiple constructors are allowed and can call each other by writing this(). If this() is present, it must be the fi rst statement in the constructor.",
      "Constructors can refer to instance variables by writing this before a variable name to indicate they want the instance variable and not the method parameter with that name. The order of initialization is the superclass (which we will cover in Chapter 5); static variables and static initializers in the order they appear; instance variables and instance initializers in the order they appear; and fi nally the constructor.",
      "Encapsulation refers to preventing callers from changing the instance variables directly. This is done by making instance variables private and getters/setters public. Immutability refers to preventing callers from changing the instance variables at all. This uses several techniques, including removing setters. JavaBeans use methods beginning with is and get for boolean and non-boolean property types, respectively. Methods beginning with set are used for setters.",
      "Lambda expressions, or lambdas, allow passing around blocks of code. The full syntax looks like (String a, String b) -> { return a.equals(b); }. The parameter types can be omitted. When only one parameter is specified without a type, the parentheses can also be omitted. The braces and return statement can be omitted for a single statement, making the short form (a -> a.equals(b). Lambdas are passed to a method expecting an interface with one method. Predicate is a common interface. It has one method named test that returns a boolean and takes any type. The removeIf() method on ArrayList takes a Predicate."

    ]
  },

  { "chapterId":5,
    "chapterName": "Class Design",
    "passed": false,"chevron":false,
    "covered":[{"title":"Working with Inheritance","covers":["Describe inheritance and its benefits", "Develop code that demonstrates the use of polymorphism; including overriding and object type versus reference type","Determine when casting is necessary","Use super and this to access objects and constructors","Use abstract classes and interfaces"]}],
    "objectives":["Be able to write code that extends other classes.","Understand the rules for method overriding.","Understand the rules for hiding methods and variables","Recognize the difference between method overriding and method overloading.","Be able to write code that creates and extends abstract classes.","Be able to write code that creates, extends, and implements interfaces.","Be able to write code that uses default and static interface methods","Understand polymorphism","Recognize valid reference casting"],
    "summary":["This chapter took the basic class structure we presented in Chapter 4 and expanded it by introducing the notion of inheritance. Java classes follow a multilevel single-inheritance pattern in which every class has exactly one direct parent class, with all classes eventually inheriting from java.lang.Object. Java interfaces simulate a limited form of multiple inheritance, since Java classes may implement multiple interfaces. ",
      "Inheriting a class gives you access to all of the public and protected methods of the class, but special rules for constructors and overriding methods must be followed or the code will not compile. For example, if the parent class doesn’t include a no-argument constructor, an explicit call to a parent constructor must be provided in the child’s constructors.Pay close attention on the exam to any class that defi nes a constructor with arguments and doesn’t defi ne a no-argument constructor. ",
      "We reviewed overloaded, overridden, and hidden methods and showed how they differ,especially in terms of polymorphism. We also introduced the notion of hiding variables,although we strongly discourage this in practice as it often leads to confusing, diffi cult-tomaintaincode. ",
      "We introduced abstract classes and interfaces and showed how you can use them to defi ne a platform for other developers to interact with. By defi nition, an abstract type cannot be instantiated directly and requires a concrete subclass for the code to be used. Since default and static interface methods are new to Java 8, expect to see at least one question on them on the exam. ",
      "Finally, this chapter introduced the concept of polymorphism, central to the Java language, and showed how objects can be accessed in a variety of forms. Make sure you understand when casts are needed for accessing objects, and be able to spot the difference between compile-time and runtime cast problems."]
  },

  { "chapterId":6,
    "chapterName": "Exceptions",
    "passed": false,"chevron":false,
    "covered":[{"title":"Handling Exceptions","covers":["Differentiate among checked exceptions, unchecked exceptions and Errors","Create a try-catch block and determine how exceptions alter normal program flow","Describe the advantages of Exception handling","Create and invoke a method that throws an exception","Recognize common exception classes (such as NullPointerException, ArithmeticException ArrayIndexOutOfBoundsException, ClassCastException)"]}],
    "objectives":["Differentiate between checked and unchecked exceptions.","Understand the flow of a try statement","Identify whether an exception is thrown by the programmer or the JVM.","Declare methods that declare exceptions.","Recognize when to use throw versus throws"],
    "summary":["An exception indicates something unexpected happened. A method can handle an exception by catching it or declaring it for the caller to deal with. Many exceptions are thrown by Java libraries. You can throw your own exception with code such as throw new Exception(). ",
      "Subclasses of java.lang.Error are exceptions that a programmer should not attempt to handle. Subclasses of java.lang.RuntimeException are runtime (unchecked) exceptions.Subclasses of java.lang.Exception, but not java.lang.RuntimeException are checked exceptions. Java requires checked exceptions to be handled or declared. ",
      "If a try statement has multiple catch blocks, at most one catch block can run. Java looks for an exception that can be caught by each catch block in the order they appear, and the first match is run. Then execution continues after the try statement. If both catch and finally throw an exception, the one from finally gets thrown. ",
      "When a method overrides a method in a superclass or interface, it is not allowed to add checked exceptions. It is allowed to declare fewer exceptions or declare a subclass of a declared exception. Methods declare exceptions with the keyword throws. ",
      "Common runtime exceptions include: ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException, NullPointerException, NumberFormatException , IllegalArgumentException. Note that IllegalArgumentException and NumberFormatException are typically thrown by the programmer, whereas the others are typically thrown by the JVM.",
      "Common checked exceptions include: IOException, FileNotFoundException",
      "Common errors include: ExceptionInInitializerError, StackOverflowError, NoClassDefFoundError"
    ]
  }
]

